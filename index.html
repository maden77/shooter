<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cacing Arena Mabar</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        canvas {
            display: block;
            background: #050515;
        }
        
        #lobby {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal {
            background: #0a0a1a;
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #a855f7;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.3);
        }
        
        h1 {
            color: #a855f7;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #a855f7;
        }
        
        input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            border: 1px solid #444;
            background: #111;
            color: white;
            text-align: center;
            font-size: 16px;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border-radius: 8px;
            border: none;
            background: #a855f7;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }
        
        button:hover {
            background: #9333ea;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .hidden {
            display: none !important;
        }
        
        #ui {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid #a855f7;
            font-size: 14px;
            z-index: 100;
        }
        
        #joy {
            position: fixed;
            bottom: 60px;
            left: 60px;
            width: 100px;
            height: 100px;
            background: rgba(168, 85, 247, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(168, 85, 247, 0.3);
        }
        
        #joy-dot {
            position: absolute;
            top: 25px;
            left: 25px;
            width: 50px;
            height: 50px;
            background: #a855f7;
            border-radius: 50%;
            transition: transform 0.1s;
        }
        
        #players {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid #22c55e;
            font-size: 12px;
            max-width: 150px;
        }
    </style>
</head>
<body>
    <!-- Lobby Screen -->
    <div id="lobby">
        <div class="modal">
            <h1>üêç CACING ARENA</h1>
            <p style="color: #888; margin-bottom: 20px;">Mabar Edition</p>
            
            <input type="text" id="name" placeholder="Nama Kamu" value="Player">
            
            <div style="margin: 15px 0; padding: 10px; border: 1px dashed #ffd700; border-radius: 8px;">
                <p style="font-size: 12px; color: #aaa;">ID Kamu:</p>
                <p id="player-id" style="font-size: 18px; color: #ffd700; font-weight: bold;">0000</p>
            </div>
            
            <button onclick="startSolo()">üéÆ MAIN SOLO</button>
            <button onclick="showMultiplayer()" style="background: #22c55e; margin-top: 10px;">üë• MABAR ONLINE</button>
            
            <div id="multi-menu" class="hidden" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                <input type="text" id="room-id" placeholder="ID Room Teman">
                <button onclick="joinRoom()" style="background: #3b82f6;">üîó GABUNG ROOM</button>
                <button onclick="createRoom()" style="background: #f59e0b; margin-top: 5px;">üè† BUAT ROOM BARU</button>
                <button onclick="hideMultiplayer()" style="background: #666; margin-top: 10px;">‚Üê KEMBALI</button>
            </div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over" class="hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 1000;">
        <div class="modal">
            <h2 style="color: #ef4444;">GAME OVER!</h2>
            <p style="margin: 15px 0;">Skor: <span id="final-score" style="color: #ffd700;">0</span></p>
            <button onclick="restartGame()" style="background: #10b981;">üîÑ MAIN LAGI</button>
        </div>
    </div>
    
    <!-- Game UI -->
    <div id="ui" class="hidden">
        ü™ô <span id="coins">0</span> | üìè <span id="length">15</span>
    </div>
    
    <div id="players" class="hidden">
        <p>üë• Pemain:</p>
        <div id="player-list"></div>
    </div>
    
    <!-- Joystick -->
    <div id="joy" class="hidden"></div>
    <div id="joy-dot" class="hidden"></div>
    
    <!-- Game Canvas -->
    <canvas id="game"></canvas>

    <script>
        // =============================================
        // BASIC INITIALIZATION
        // =============================================
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Player ID
        let myId = localStorage.getItem('snake-player-id');
        if (!myId) {
            myId = Math.floor(1000 + Math.random() * 9000).toString();
            localStorage.setItem('snake-player-id', myId);
        }
        document.getElementById('player-id').textContent = myId;
        
        // Player name
        let myName = localStorage.getItem('snake-player-name') || "Player";
        document.getElementById('name').value = myName;
        
        // Game variables
        let gameActive = false;
        let gameMode = 'solo'; // 'solo', 'host', 'client'
        let player = null;
        let foods = [];
        let bots = [];
        let viewport = { x: 0, y: 0 };
        
        // =============================================
        // SNAKE CLASS - DIPERBAIKI COLLISION
        // =============================================
        class Snake {
            constructor(x, y, color, name, isBot = false) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.name = name;
                this.isBot = isBot;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = isBot ? 1.5 : 3;
                this.radius = 10; // Radius untuk collision
                this.alive = true;
                this.score = 0;
                this.segments = [];
                
                // Create initial body
                for (let i = 0; i < 15; i++) {
                    this.segments.push({
                        x: this.x - i * 2,
                        y: this.y
                    });
                }
                
                if (isBot) {
                    this.targetFood = null;
                    this.turnTimer = 0;
                    this.wanderAngle = Math.random() * Math.PI * 2;
                }
            }
            
            update() {
                if (!this.alive) return;
                
                // Bot AI
                if (this.isBot) {
                    this.updateBot();
                }
                
                // Move
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Update segments
                this.segments.unshift({ x: this.x, y: this.y });
                if (this.segments.length > 50) { // Limit max length
                    this.segments.pop();
                }
            }
            
            updateBot() {
                this.turnTimer--;
                
                if (this.turnTimer <= 0 || !this.targetFood) {
                    // Find nearest food
                    let closestFood = null;
                    let closestDist = Infinity;
                    
                    for (const food of foods) {
                        const dx = food.x - this.x;
                        const dy = food.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < closestDist && dist < 600) {
                            closestDist = dist;
                            closestFood = food;
                        }
                    }
                    
                    this.targetFood = closestFood;
                    this.turnTimer = 30 + Math.random() * 30;
                }
                
                // Move towards food or wander
                if (this.targetFood) {
                    const targetAngle = Math.atan2(
                        this.targetFood.y - this.y,
                        this.targetFood.x - this.x
                    );
                    
                    let diff = targetAngle - this.angle;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    
                    this.angle += diff * 0.08;
                } else {
                    // Wandering behavior
                    this.wanderAngle += (Math.random() - 0.5) * 0.3;
                    let diff = this.wanderAngle - this.angle;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    
                    this.angle += diff * 0.05;
                }
            }
            
            checkFoodCollision() {
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const dx = this.x - food.x;
                    const dy = this.y - food.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 20) {
                        // Eat food
                        foods.splice(i, 1);
                        spawnFood();
                        
                        // Grow - tambah segment baru
                        const tail = this.segments[this.segments.length - 1];
                        this.segments.push({ x: tail.x, y: tail.y });
                        this.segments.push({ x: tail.x, y: tail.y }); // Tambah 2 segment
                        
                        // Add score
                        this.score += 5;
                        
                        // Play sound and add coins if player
                        if (!this.isBot) {
                            playEatSound();
                            gameData.coins += 3;
                            updateUI();
                            
                            // Vibration feedback on mobile
                            if (navigator.vibrate) {
                                navigator.vibrate(30);
                            }
                        }
                        
                        break;
                    }
                }
            }
            
            // Function to check collision with other snake
            checkCollisionWith(otherSnake) {
                if (!otherSnake || !otherSnake.alive || this === otherSnake) return false;
                
                const head = this.segments[0];
                
                // Check collision with other snake's head
                const otherHead = otherSnake.segments[0];
                const headDist = Math.sqrt(
                    Math.pow(head.x - otherHead.x, 2) + 
                    Math.pow(head.y - otherHead.y, 2)
                );
                
                // If heads collide, both die (unless player vs bot - player wins)
                if (headDist < this.radius + otherSnake.radius) {
                    if (this.isBot && !otherSnake.isBot) {
                        // Player hits bot head - bot dies
                        return 'bot_dies';
                    } else if (!this.isBot && otherSnake.isBot) {
                        // Bot hits player head - player dies
                        return 'player_dies';
                    } else {
                        // Head-to-head collision
                        return 'both_die';
                    }
                }


           checkCollisionWith(otherSnake) {
    if (!otherSnake || !otherSnake.alive || this === otherSnake) return false;
    
    const head = this.segments[0];
    
    // Check collision with other snake's head
    const otherHead = otherSnake.segments[0];
    const headDist = Math.sqrt(
        Math.pow(head.x - otherHead.x, 2) + 
        Math.pow(head.y - otherHead.y, 2)
    );
    
    // Jika kepala bertabrakan:
    if (headDist < this.radius + otherSnake.radius) {
        // PLAYER vs BOT: Bot selalu mati, Player selamat
        if (!this.isBot && otherSnake.isBot) {
            // Player nabrak kepala bot ‚Üí Bot mati
            return 'bot_dies';
        } else if (this.isBot && !otherSnake.isBot) {
            // Bot nabrak kepala player ‚Üí Bot mati juga (Player selamat)
            return 'bot_dies';
        }
        // Bot vs Bot: keduanya mati
        return 'both_die';
    }
    
    // Check collision with other snake's body
    for (let i = 3; i < otherSnake.segments.length; i++) {
        const segment = otherSnake.segments[i];
        const dist = Math.sqrt(
            Math.pow(head.x - segment.x, 2) + 
            Math.pow(head.y - segment.y, 2)
        );
        
        if (dist < this.radius + 5) {
            // PLAYER vs BOT BODY: Bot mati
            if (!this.isBot && otherSnake.isBot) {
                // Player nabrak tubuh bot ‚Üí Bot mati
                return 'bot_dies';
            } else if (this.isBot && !otherSnake.isBot) {
                // Bot nabrak tubuh player ‚Üí Bot mati juga
                return 'bot_dies';
            }
            // Bot vs Bot body: keduanya mati
            return 'both_die';
        }
    }
    
    return false;
}
        checkSelfCollision() {
                if (this.isBot) return false; // Bots don't die from self-collision
                
                const head = this.segments[0];
                
                // Check collision with own body (skip first 4 segments near head)
                for (let i = 4; i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    const dx = head.x - segment.x;
                    const dy = head.y - segment.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < this.radius) {
                        return true;
                    }
                }
                
                return false;
            }          
                   // HANYA CHECK JIKA PLAYER NABRAK BOT
            checkCollisionWithBot(bot) {
                if (!bot || !bot.alive || this.isBot) return false;
                
                const head = this.segments[0];
                
                // Check collision with bot's head
                const botHead = bot.segments[0];
                const headDist = Math.sqrt(
                    Math.pow(head.x - botHead.x, 2) + 
                    Math.pow(head.y - botHead.y, 2)
                );
                
                // Jika player nabrak kepala bot
                if (headDist < this.radius + bot.radius) {
                    return true;
                }
                
                // Check collision with bot's body
                for (let i = 0; i < bot.segments.length; i++) {
                    const segment = bot.segments[i];
                    const dist = Math.sqrt(
                        Math.pow(head.x - segment.x, 2) + 
                        Math.pow(head.y - segment.y, 2)
                    );
                    
                    // Jika player nabrak tubuh bot
                    if (dist < this.radius + 5) {
                        return true;
                    }
                }
                
                return false;
            }
                
              
            
            
            die(killer = null) {
                if (!this.alive) return;
                
                this.alive = false;
                
                // Create food from dead snake
                const foodCount = Math.min(this.segments.length, 20);
                for (let i = 0; i < foodCount; i++) {
                    const segment = this.segments[Math.floor(i * this.segments.length / foodCount)];
                    foods.push({
                        x: segment.x + (Math.random() - 0.5) * 40,
                        y: segment.y + (Math.random() - 0.5) * 40,
                        type: Math.floor(Math.random() * 3),
                        value: 10
                    });
                }
                
                if (!this.isBot) {
                    // Player died
                    gameOver();
                    playDeathSound();
                    if (navigator.vibrate) navigator.vibrate(400);
                } else {
                    // Bot died - give score to player if killed by player
                    if (killer && !killer.isBot) {
                        killer.score += 50;
                        gameData.coins += 10;
                        updateUI();
                        playEatSound();
                    }
                    
                    // Respawn bot after delay
                    setTimeout(() => {
                        if (player && player.alive) {
                            const index = bots.indexOf(this);
                            if (index > -1) {
                                // Spawn bot away from player
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 400 + Math.random() * 400;
                                bots[index] = new Snake(
                                    player.x + Math.cos(angle) * distance,
                                    player.y + Math.sin(angle) * distance,
                                    getRandomBotColor(),
                                    'Bot ' + (index + 1),
                                    true
                                );
                            }
                        }
                    }, 2000);
                }
            }
            
            draw() {
                if (!this.alive) return;
                
                // Draw body
                ctx.save();
                ctx.lineWidth = 16;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.strokeStyle = this.color;
                
                ctx.beginPath();
                for (let i = 0; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    if (i === 0) {
                        ctx.moveTo(seg.x - viewport.x, seg.y - viewport.y);
                    } else {
                        ctx.lineTo(seg.x - viewport.x, seg.y - viewport.y);
                    }
                }
                ctx.stroke();
                
                // Draw head
                const head = this.segments[0];
                ctx.fillStyle = this.isBot ? '#ff4444' : 'white';
                ctx.beginPath();
                ctx.arc(head.x - viewport.x, head.y - viewport.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw eyes
                ctx.fillStyle = 'black';
                const eyeOffset = this.isBot ? 2 : 3;
                ctx.beginPath();
                ctx.arc(head.x - viewport.x - eyeOffset, head.y - viewport.y - 3, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(head.x - viewport.x + eyeOffset, head.y - viewport.y - 3, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw name
                ctx.fillStyle = this.isBot ? '#ff8888' : 'white';
                ctx.font = 'bold ' + (this.isBot ? '11' : '12') + 'px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, head.x - viewport.x, head.y - viewport.y - 20);
                
                ctx.restore();
            }
        }
        
        // Helper function for bot colors
        function getRandomBotColor() {
            const colors = ['#ef4444', '#f97316', '#dc2626', '#b91c1c', '#991b1b'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // =============================================
        // GAME FUNCTIONS
        // =============================================
        function startSolo() {
            startGame('solo');
        }
        
        function startGame(mode) {
            myName = document.getElementById('name').value.trim() || "Player";
            localStorage.setItem('snake-player-name', myName);
            
            gameMode = mode;
            gameActive = true;
            
            // Hide lobby
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('joy').classList.remove('hidden');
            document.getElementById('joy-dot').classList.remove('hidden');
            
            if (mode === 'host' || mode === 'client') {
                document.getElementById('players').classList.remove('hidden');
            }
            
            // Reset game state
            player = new Snake(0, 0, '#a855f7', myName);
            foods = [];
            bots = [];
            viewport = { x: 0, y: 0 };
            
            // Spawn initial food
            for (let i = 0; i < 50; i++) {
                spawnFood(true);
            }
            
            // Spawn bots for solo mode
            if (mode === 'solo') {
                for (let i = 0; i < 8; i++) { // Kurangi jumlah bot untuk performa
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 300 + Math.random() * 300;
                    bots.push(new Snake(
                        Math.cos(angle) * distance,
                        Math.sin(angle) * distance,
                        getRandomBotColor(),
                        'Bot ' + (i + 1),
                        true
                    ));
                }
            }
            
            // Load game data
            loadGameData();
            updateUI();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        function spawnFood(initial = false) {
            let x, y;
            
            if (initial) {
                x = (Math.random() - 0.5) * 3000;
                y = (Math.random() - 0.5) * 3000;
            } else {
                // Spawn near player but not too close
                const angle = Math.random() * Math.PI * 2;
                const distance = 200 + Math.random() * 300;
                x = player.x + Math.cos(angle) * distance;
                y = player.y + Math.sin(angle) * distance;
            }
            
            foods.push({
                x: x,
                y: y,
                type: Math.floor(Math.random() * 3),
                rotation: Math.random() * Math.PI * 2
            });
        }
        
        function gameLoop() {
            if (!gameActive) return;
            
            // Clear canvas with fade effect
            ctx.fillStyle = 'rgba(5, 5, 21, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update viewport to follow player
            if (player && player.alive) {
                viewport.x = player.x - canvas.width / 2;
                viewport.y = player.y - canvas.height / 2;
            }
            
            // Draw grid background
            drawGrid();
            
            // Update and check collisions for player
            if (player && player.alive) {
                player.update();
                player.checkFoodCollision();
                
                // Check self-collision
                if (player.checkSelfCollision()) {
                    player.die();
                }
                
                // Check collision with bots
                for (let i = bots.length - 1; i >= 0; i--) {
                    const bot = bots[i];
                    if (!bot.alive) continue;
                    
                    const collision = player.checkCollisionWith(bot);
                    if (collision === 'player_dies') {
                        player.die(bot);
                        break;
                    } else if (collision === 'bot_dies') {
                        bot.die(player);
                        // Remove dead bot immediately
                        bots.splice(i, 1);
                    }
                }
            }
            
            // Update and draw bots
            for (const bot of bots) {
                if (bot.alive) {
                    bot.update();
                    bot.checkFoodCollision();
                    
                    // Check bot-bot collisions (optional, bisa dihapus untuk performa)
                    for (const otherBot of bots) {
                        if (bot !== otherBot && bot.alive && otherBot.alive) {
                            const collision = bot.checkCollisionWith(otherBot);
                            if (collision === 'both_die') {
                                bot.die();
                                otherBot.die();
                            }
                        }
                    }
                }
            }
            
            // Draw all entities
            drawFoods();
            
            if (player) {
                player.draw();
            }
            
            bots.forEach(bot => bot.draw());
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }
        
        function drawGrid() {
            const gridSize = 100;
            const startX = Math.floor(viewport.x / gridSize) * gridSize;
            const startY = Math.floor(viewport.y / gridSize) * gridSize;
            
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.05)';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = startX; x < startX + canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x - viewport.x, 0);
                ctx.lineTo(x - viewport.x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = startY; y < startY + canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y - viewport.y);
                ctx.lineTo(canvas.width, y - viewport.y);
                ctx.stroke();
            }
        }
        
        function drawFoods() {
            foods.forEach(food => {
                ctx.save();
                ctx.translate(food.x - viewport.x, food.y - viewport.y);
                food.rotation += 0.01;
                ctx.rotate(food.rotation);
                
                // Draw different food types
                switch(food.type) {
                    case 0: // Apple
                        ctx.fillStyle = '#ef4444';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Stem
                        ctx.fillStyle = '#22c55e';
                        ctx.fillRect(-1.5, -10, 3, 4);
                        break;
                        
                    case 1: // Banana
                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 10, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 2: // Berry
                        ctx.fillStyle = '#8b5cf6';
                        ctx.beginPath();
                        ctx.arc(0, 0, 7, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Highlight
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(-2, -2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
            });
        }
        
        function gameOver() {
            gameActive = false;
            
            document.getElementById('final-score').textContent = player.score;
            document.getElementById('game-over').classList.remove('hidden');
            
            // Save game data
            saveGameData();
        }
        
        function restartGame() {
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('lobby').classList.remove('hidden');
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('joy').classList.add('hidden');
            document.getElementById('joy-dot').classList.add('hidden');
            document.getElementById('players').classList.add('hidden');
        }
        
        // =============================================
        // GAME DATA & UI
        // =============================================
        let gameData = {
            coins: 0,
            highScore: 0
        };
        
        function loadGameData() {
            const saved = localStorage.getItem('snake-game-data');
            if (saved) {
                gameData = JSON.parse(saved);
            }
        }
        
        function saveGameData() {
            if (player.score > gameData.highScore) {
                gameData.highScore = player.score;
            }
            localStorage.setItem('snake-game-data', JSON.stringify(gameData));
        }
        
        function updateUI() {
            if (!player) return;
            
            document.getElementById('coins').textContent = gameData.coins;
            document.getElementById('length').textContent = player.segments.length;
        }
        
        // =============================================
        // CONTROLS
        // =============================================
        let joyActive = false;
        
        // Touch controls
        document.getElementById('joy').addEventListener('touchstart', (e) => {
            e.preventDefault();
            joyActive = true;
            updateJoystick(e.touches[0]);
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!joyActive || !player || !player.alive) return;
            e.preventDefault();
            updateJoystick(e.touches[0]);
        });
        
        document.addEventListener('touchend', () => {
            joyActive = false;
            document.getElementById('joy-dot').style.transform = 'translate(0, 0)';
        });
        
        // Mouse controls for desktop
        document.getElementById('joy').addEventListener('mousedown', (e) => {
            e.preventDefault();
            joyActive = true;
            updateJoystick(e);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!joyActive || !player || !player.alive) return;
            e.preventDefault();
            updateJoystick(e);
        });
        
        document.addEventListener('mouseup', () => {
            joyActive = false;
            document.getElementById('joy-dot').style.transform = 'translate(0, 0)';
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!player || !player.alive) return;
            
            switch(e.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    player.angle = -Math.PI / 2;
                    break;
                case 'arrowdown':
                case 's':
                    player.angle = Math.PI / 2;
                    break;
                case 'arrowleft':
                case 'a':
                    player.angle = Math.PI;
                    break;
                case 'arrowright':
                case 'd':
                    player.angle = 0;
                    break;
            }
        });
        
        function updateJoystick(input) {
            if (!player || !player.alive) return;
            
            const joy = document.getElementById('joy');
            const joyRect = joy.getBoundingClientRect();
            
            const centerX = joyRect.left + joyRect.width / 2;
            const centerY = joyRect.top + joyRect.height / 2;
            
            let dx = input.clientX - centerX;
            let dy = input.clientY - centerY;
            
            // Limit to circle
            const distance = Math.sqrt(dx*dx + dy*dy);
            const maxDist = joyRect.width / 2 - 25;
            
            if (distance > maxDist) {
                dx = (dx / distance) * maxDist;
                dy = (dy / distance) * maxDist;
            }
            
            // Update joystick dot position
            document.getElementById('joy-dot').style.transform = `translate(${dx}px, ${dy}px)`;
            
            // Update player direction
            player.angle = Math.atan2(dy, dx);
        }
        
        // =============================================
        // SOUND FUNCTIONS
        // =============================================
        function playEatSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                // Sound not supported, ignore
            }
        }
        
        function playDeathSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(180, audioContext.currentTime);
                oscillator.frequency.linearRampToValueAtTime(60, audioContext.currentTime + 0.5);
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                // Sound not supported, ignore
            }
        }
        
        // =============================================
        // MULTIPLAYER FUNCTIONS (Simplified)
        // =============================================
        function showMultiplayer() {
            document.getElementById('multi-menu').classList.remove('hidden');
        }
        
        function hideMultiplayer() {
            document.getElementById('multi-menu').classList.add('hidden');
        }
        
        function createRoom() {
            alert('Fitur Mabar (Buat Room) sedang dalam pengembangan!\nUntuk sekarang, mainkan mode Solo dulu.');
            hideMultiplayer();
        }
        
        function joinRoom() {
            const roomId = document.getElementById('room-id').value;
            if (!roomId || roomId.length !== 4) {
                alert('Masukkan ID Room 4 digit yang valid!');
                return;
            }
            alert('Fitur Mabar (Gabung Room) sedang dalam pengembangan!\nUntuk sekarang, mainkan mode Solo dulu.');
            hideMultiplayer();
        }
        
        // =============================================
        // INITIALIZE GAME
        // =============================================
        console.log('Game initialized successfully!');
    </script>
</body>
</html>
